# 学习笔记

### 200
老师上课讲过了，思路有了，这次自己用代码实现了一遍。

### 295
看上去很简单，使用二分查找，然后找到位置插入。但是实际写代码要考虑边界值，以及要考虑二分查找的写法，因为要拿到具体插入的位置，而不是只要没有找到就返回，所以这里卡了几次提交。

看到评论里用大根堆和小根堆来解决很巧妙，可惜PHP没有这种数据结构，所以还是使用二分查找插入的方法了。

### 210
学习了典型的有向无环图的拓扑排序的解法。

> 1. 选择一个入度为0的顶点并输出之；  
> 2. 从网中删除此顶点及所有出边。  
> 3. 循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。

### 104
递归dfs深度查询，拿到左右子树中最大深度，加上根节点就为最大深度。

### 547
最开始想到这道题跟岛屿问题是一样的，代码写完之后测试发现我理解错了，这里不一样的地方在于当每一行存在一个"1"的时候，那么这一点所在的行和列都算作一个朋友圈子，这就无法用岛屿问题来解决了。其实这样也比岛屿问题更简单些，只需要一次遍历行或列，累加每一个未访问过的点，然后记录每一个访问过为"1"的点的坐标，对这个点的行和列进行递归，最后返回计数值。

### 329
用到深度优先dfs算法，从0，0起点开始遍历数组，递归计算每一点邻接4个点的最长路径，并记录下每一点最终计算求得的最大深度作为记忆，因为后面的点递归必然会用到之前计算过的点，那么记忆下来提高效率。  
对于长度和宽度的计算一定要搞清，不然很容易搞混自己定义的二维数组的长度和宽度。

### 320
构建图的hash表，以入度为1的节点为叶子节点，循环清除叶子节点，并从hash表中移除叶子节点的根节点关联数据，并判断根节点大小是否为1，为1则将根节点入叶子节点队列，继续bfs循环处理，最后结束条件是只剩下1个或2个节点，将叶子节点队列剩余的数据打印输出。

### 111
dfs取树最小深度，同104题取最大深度的不同在于，当一个节点只有左子树或右子树时需要分别判断计算。

### 802
使用深度优先dfs算法计算每一个起点是否有环，有环则此节点为不安全节点。因为每个节点可能会被多次访问，不用每次都重新计算当前节点的状态，那么存储每一个遍历过的节点的安全状态，避免多次重复计算同一节点。

### 703
初始化的时候使用快速排序使数组由大到小有序，之后每次插入截取到取的位置做二分排序插入，最后得出所求。